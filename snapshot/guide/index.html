<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>Grails Async Framework</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8" />
    <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    <script src="../js/docs.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.5.13/clipboard.min.js"></script>
    <script type="text/javascript">
        function addJsClass(el) {
            var classes = document.body.className.split(" ");
            classes.push("js");
            document.body.className = classes.join(" ");
        }
    </script>
</head>

<body class="body" onload="addJsClass();">
<div id="navigation">
    <div class="navTitle">
        
        Grails Async Framework
    </div>
    <div class="navLinks">
        <ul>
            <li>
                <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                    <a href="../guide/index.html" class="button">Table of contents</a>
                    <div id="nav-summary-childs" style="display:none;">
                        
                        <div class="toc-item" style="margin-left:0"><a href="#introduction"><strong>1</strong><span>Introduction</span></a></div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="#promises"><strong>2</strong><span>Promises</span></a></div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="#events"><strong>3</strong><span>Events</span></a></div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="#asyncGorm"><strong>4</strong><span>Asynchronous GORM</span></a></div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="#rxjava"><strong>5</strong><span>RxJava Support</span></a></div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="#asyncRequests"><strong>6</strong><span>Asynchronous Request Handling</span></a></div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="#asyncServletApi"><strong>7</strong><span>Servlet 3.0 Async</span></a></div>
                        
                    </div>
                </div>
            </li>
            <li>
                <a href="../api/index.html" class="button">API Reference</a>
            </li>
        </ul>

    </div>
</div>


<table id="colset" border="0" cellpadding="0" cellspacing="0">
    <tr>
        <td id="col1">
            <div id="main" class="corner-all">

                <div class="project">
                    <h1>Grails Async Framework</h1>
                    <p></p>
                    <p>Grails Async Libraries</p>
                    <p><strong>Version:</strong> 4.0.0.BUILD-SNAPSHOT</p>

                </div>

                

<h1 id="introduction">1 Introduction</h1>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/introduction.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>With modern hardware featuring multiple cores, many programming languages have been adding asynchronous, parallel programming APIs, Groovy being no exception.</p>
</div>
<div class="paragraph">
<p>Added Grails 2.3 and since 3.3 an external project, the Async features of Grails aim to simplify concurrent programming within the framework and include the concept of Promises and a unified event model.</p>
</div>


<h1 id="promises">2 Promises</h1>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/promises.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>A Promise is a concept being embraced by many concurrency frameworks. They are similar to <code>java.util.concurrent.Future</code> instances, but include a more user friendly exception handling model, useful features like chaining and the ability to attach listeners.</p>
</div>
<div class="paragraph">
<p>To use the Grails Promise abstraction you should add a dependency on the <code>async</code> plugin to your <code>build.gradle</code> file:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">runtime "org.grails.plugins:async:4.0.0.BUILD-SNAPSHOT"</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_promise_basics">Promise Basics</h3>
<div class="paragraph">
<p>In Grails the <code>grails.async.Promises</code> class provides the entry point to the Promise API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To create promises you can use the <code>task</code> method, which returns an instance of the <code>grails.async.Promise</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> p1 = task { <span class="integer">2</span> * <span class="integer">2</span> }
<span class="keyword">def</span> p2 = task { <span class="integer">4</span> * <span class="integer">4</span> }
<span class="keyword">def</span> p3 = task { <span class="integer">8</span> * <span class="integer">8</span> }
<span class="keyword">assert</span> [<span class="integer">4</span>,<span class="integer">16</span>,<span class="integer">64</span>] == waitAll(p1, p2, p3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>waitAll</code> method waits synchronously, blocking the current thread, for all of the concurrent tasks to complete and returns the results.</p>
</div>
<div class="paragraph">
<p>If you prefer not to block the current thread you can use the <code>onComplete</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">onComplete([p1,p2,p3]) { <span class="predefined-type">List</span> results -&gt;
   <span class="keyword">assert</span> [<span class="integer">4</span>,<span class="integer">16</span>,<span class="integer">64</span>] == results
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>waitAll</code> method will throw an exception if an error occurs executing one of the promises. The originating exception will be thrown. The <code>onComplete</code> method, however, will simply not execute the passed closure if an exception occurs. You can register an <code>onError</code> listener if you wish to handle exceptions without blocking:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">onError([p1,p2,p3]) { <span class="predefined-type">Throwable</span> t -&gt;
   println <span class="string"><span class="delimiter">&quot;</span><span class="content">An error occured </span><span class="inline"><span class="inline-delimiter">${</span>t.message<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have just a single long running promise then the <code>grails.async.Promise</code> interface provides a similar API on the promise itself. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">java.util.concurrent.TimeUnit.*</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

Promise p = task {
        <span class="comment">// Long running task</span>
}
p.onError { <span class="predefined-type">Throwable</span> err -&gt;
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">An error occured </span><span class="inline"><span class="inline-delimiter">${</span>err.message<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}
p.onComplete { result -&gt;
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Promise returned </span><span class="inline"><span class="inline-delimiter">$</span>result</span><span class="delimiter">&quot;</span></span>
}
<span class="comment">// block until result is called</span>
<span class="keyword">def</span> result = p.get()
<span class="comment">// block for the specified time</span>
<span class="keyword">def</span> result = p.get(<span class="integer">1</span>,MINUTES)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_promisefactory_interface">The PromiseFactory Interface</h3>
<div class="paragraph">
<p>By default the <code>Promises</code> static methods use an instance of <code>PromiseFactory</code>. This <code>PromiseFactory</code> interface has various implementations. The default implementation is <a href="../api/org/grails/async/factory/future/CachedThreadPoolPromiseFactory.html">CachedThreadPoolPromiseFactory</a> which uses a thread pool that will create threads as needed (the same as <code>java.util.concurrent.Executors.newCachedThreadPool()</code>)</p>
</div>
<div class="paragraph">
<p>However, the design of the Grails promises framework is such that you can swap out the underlying implementation for your own or one of the pre-supported implementations. For example to use RxJava 1.x simply add the RxJava dependency to <code>build.gradle</code>:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">runtime "org.grails:grails-async-rxjava:4.0.0.BUILD-SNAPSHOT"</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the above in place RxJava 1.x will be used to create <code>Promise</code> instances.</p>
</div>
<div class="paragraph">
<p>The following table summarizes the available implementation and the dependency that should be added to activate them:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Promise Factory Implementations</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Framework</th>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Implementation Class</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPars 1.2.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>grails-async-gpars</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.grails.async.factory.gpars.GparsPromiseFactory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RxJava 1.2.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>grails-async-rxjava</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.grails.async.factory.rxjava.RxPromiseFactory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RxJava 2.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>grails-async-rxjava2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.grails.async.factory.rxjava2.RxPromiseFactory</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can also override the <code>grails.async.PromiseFactory</code> class used by <code>Promises</code> by setting the <code>promiseFactory</code> static field.</p>
</div>
<div class="paragraph">
<p>One common use case for this is unit testing, typically you do not want promises to execute asynchronously during unit tests, as this makes tests harder to write. For this purpose Grails ships with a <code>org.grails.async.factory.SynchronousPromiseFactory</code> instance that makes it easier to test promises:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.grails.async.factory.*</span>
<span class="keyword">import</span> <span class="include">grails.async.*</span>

Promises.promiseFactory = <span class="keyword">new</span> SynchronousPromiseFactory()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the <code>PromiseFactory</code> mechanism it is theoretically possible to plug in other concurrency libraries into the Grails framework. For this you need to override the two interfaces <code>grails.async.Promise</code> and <code>grails.async.PromiseFactory</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_promise_chaining">Promise Chaining</h3>
<div class="paragraph">
<p>It is possible to chain several promises and wait for the chain to complete using the <code>then</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="directive">final</span> polish = { ... }
<span class="directive">final</span> transform = { ... }
<span class="directive">final</span> save = { ... }
<span class="directive">final</span> notify = { ... }

Promise promise = task {
    <span class="comment">// long running task</span>
}
promise.then polish then transform then save then {
        <span class="comment">// notify end result</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an exception occurs at any point in the chain it will be propagated back to the caller and the next step in the chain will not be called.</p>
</div>
</div>
<div class="sect2">
<h3 id="_promise_lists_and_maps">Promise Lists and Maps</h3>
<div class="paragraph">
<p>Grails' async API also features the concept of a promise lists and maps. These are represented by the <code>grails.async.PromiseList</code> and <code>grails.async.PromiseMap</code> classes respectively.</p>
</div>
<div class="paragraph">
<p>The easiest way to create a promise list or map is via the <code>tasks</code> method of the <code>Promises</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

<span class="keyword">def</span> promiseList = tasks([{ <span class="integer">2</span> * <span class="integer">2</span> }, { <span class="integer">4</span> * <span class="integer">4</span>}, { <span class="integer">8</span> * <span class="integer">8</span> }])

<span class="keyword">assert</span> [<span class="integer">4</span>,<span class="integer">16</span>,<span class="integer">64</span>] == promiseList.get()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>tasks</code> method, when passed a list of closures, returns a <code>PromiseList</code>. You can also construct a <code>PromiseList</code> manually:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.async.*</span>

<span class="keyword">def</span> list = <span class="keyword">new</span> PromiseList()
list &lt;&lt; { <span class="integer">2</span> * <span class="integer">2</span> }
list &lt;&lt; { <span class="integer">4</span> * <span class="integer">4</span> }
list &lt;&lt; { <span class="integer">8</span> * <span class="integer">8</span> }
list.onComplete { <span class="predefined-type">List</span> results -&gt;
  <span class="keyword">assert</span> [<span class="integer">4</span>,<span class="integer">16</span>,<span class="integer">64</span>] == results
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>PromiseList</code> class does not implement the java.util.List interface, but instead returns a java.util.List from the get() method
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Working with <code>PromiseMap</code> instances is largely similar. Again you can either use the <code>tasks</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

<span class="keyword">def</span> promiseList = tasks <span class="key">one</span>:{ <span class="integer">2</span> * <span class="integer">2</span> },
                        <span class="key">two</span>:{ <span class="integer">4</span> * <span class="integer">4</span>},
                        <span class="key">three</span>:{ <span class="integer">8</span> * <span class="integer">8</span> }

<span class="keyword">assert</span> [<span class="key">one</span>:<span class="integer">4</span>,<span class="key">two</span>:<span class="integer">16</span>,<span class="key">three</span>:<span class="integer">64</span>] == promiseList.get()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or construct a <code>PromiseMap</code> manually:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.async.*</span>

<span class="keyword">def</span> map = <span class="keyword">new</span> PromiseMap()
map[<span class="string"><span class="delimiter">'</span><span class="content">one</span><span class="delimiter">'</span></span>] = { <span class="integer">2</span> * <span class="integer">2</span> }
map[<span class="string"><span class="delimiter">'</span><span class="content">two</span><span class="delimiter">'</span></span>] = { <span class="integer">4</span> * <span class="integer">4</span> }
map[<span class="string"><span class="delimiter">'</span><span class="content">three</span><span class="delimiter">'</span></span>] = { <span class="integer">8</span> * <span class="integer">8</span> }
map.onComplete { <span class="predefined-type">Map</span> results -&gt;
  <span class="keyword">assert</span> [<span class="key">one</span>:<span class="integer">4</span>,<span class="key">two</span>:<span class="integer">16</span>,<span class="key">three</span>:<span class="integer">64</span>] == results
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_delegateasync_transformation">DelegateAsync Transformation</h3>
<div class="paragraph">
<p>It is quite common to require both synchronous and asynchronous versions of the same API. Developing both can result in a maintenance problem as typically the asynchronous API would simply delegate to the synchronous version.</p>
</div>
<div class="paragraph">
<p>The <code>DelegateAsync</code> transformation is designed to mitigate this problem by transforming any synchronous API into an asynchronous one.</p>
</div>
<div class="paragraph">
<p>For example, consider the following service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">BookService</span> {
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Book</span>&gt; findBooks(<span class="predefined-type">String</span> title) {
      <span class="comment">// implementation</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>findBooks</code> method executes synchronously in the same thread as the caller. To make an asynchronous version of this API you can define another class as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.async.*</span>

<span class="type">class</span> <span class="class">AsyncBookService</span> {
   <span class="annotation">@DelegateAsync</span> BookService bookService
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DelegateAsync</code> transformation will automatically add a new method that looks like the following to the <code>AsyncBookService</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Promise&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">Book</span>&gt;&gt; findBooks(<span class="predefined-type">String</span> title) {
    Promises.task {
       bookService.findBooks(title)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you see the transform adds equivalent methods that return a Promise and execute asynchronously.</p>
</div>
<div class="paragraph">
<p>The <code>AsyncBookService</code> can then be injected into other controllers and services and used as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">AsyncBookService asyncBookService
<span class="keyword">def</span> <span class="function">findBooks</span>(<span class="predefined-type">String</span> title) {
    asyncBookService.findBooks(title)
       .onComplete { <span class="predefined-type">List</span> results -&gt;
          println <span class="string"><span class="delimiter">&quot;</span><span class="content">Books = </span><span class="inline"><span class="inline-delimiter">${</span>results<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
       }
}</code></pre>
</div>
</div>
</div>


<h1 id="events">3 Events</h1>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/events.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>Grails 3.3 introduces a new Events API that replaces the previous implementation that was based on Reactor 2.x (which is no longer maintained and deprecated).</p>
</div>
<div class="paragraph">
<p>In Grails 3.3 and above a new <a href="../api/grails/events/bus/EventBus.html">EventBus</a> abstraction has been introduced. Like the <code>PromiseFactory</code> notion, there are implementations of the <code>EventBus</code> interface for common asynchronous frameworks like GPars and RxJava.</p>
</div>
<div class="paragraph">
<p>To use the Grails Events abstraction you should add a dependency on the <code>events</code> plugin to your <code>build.gradle</code> file:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">runtime "org.grails.plugins:events:4.0.0.BUILD-SNAPSHOT"</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no asynchronous framework in present on the classpath then by default Grails creates an EventBus based off of the currently active <code>PromiseFactory</code>. The default implementation is <a href="../api/org/grails/async/factory/future/CachedThreadPoolPromiseFactory.html">CachedThreadPoolPromiseFactory</a> which uses a thread pool that will create threads as needed (the same as <code>java.util.concurrent.Executors.newCachedThreadPool()</code>).</p>
</div>
<div class="paragraph">
<p>If you wish to use a popular async framework such as RxJava as the <code>EventBus</code> implementation then you will need to add the appropriate dependency. For example for RxJava 1.x:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">runtime "org.grails:grails-events-rxjava:4.0.0.BUILD-SNAPSHOT"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following table summarizes async framework support and the necessary dependency:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. EventBus Implementations</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Framework</th>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Implementation Class</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPars 1.2.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>grails-events-gpars</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.grails.events.gpars.ActorEventBus</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RxJava 1.2.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>grails-events-rxjava</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.grails.events.rxjava.RxEventBus</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RxJava 2.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>grails-events-rxjava2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.grails.events.rxjava2.RxEventBus</code></p></td>
</tr>
</tbody>
</table>


<h2 id="notifying">3.1 Event Publishing</h2>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/events/notifying.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>The simplest way to trigger event notification is via the <a href="../api/grails/events/annotation/Publisher.html">Publisher</a> annotation.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="title">SumService.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.events.annotation.*</span>
...
class SumService {
    <span class="annotation">@Publisher</span>
    <span class="type">int</span> sum(<span class="type">int</span> a, <span class="type">int</span> b) {
        a + b
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What the above does is take the return value of the method and publish an event using an event <code>id</code> that is the same as the method name.</p>
</div>
<div class="paragraph">
<p>If you wish to change the event <code>id</code> you can provide a value to <code>@Publisher</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Publisher</span>(<span class="string"><span class="delimiter">'</span><span class="content">myEvent</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want more flexiblity then you could simulate the behaviour of annotation by writing the following code:</p>
</div>
<div class="listingblock">
<div class="title">SumService.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.events.*</span>
...
class SumService <span class="directive">implements</span> EventPublisher {
    <span class="type">int</span> sum(<span class="type">int</span> a, <span class="type">int</span> b) {
        <span class="type">int</span> result = a + b
        notify(<span class="string"><span class="delimiter">&quot;</span><span class="content">sum</span><span class="delimiter">&quot;</span></span>, result)
        <span class="keyword">return</span> result
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice in the above example, the <a href="../api/grails/events/EventPublisher.html">EventPublisher</a> trait is explicitly implemented.</p>
</div>
<div class="paragraph">
<p>Although generally the annotation approach is recommended because it is simpler and more concise, the <code>EventPublisher</code> trait does provide more flexibility in terms of being able to publish multiple events in a single method and so on.</p>
</div>


<h2 id="consuming">3.2 Subscribing to Events</h2>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/events/consuming.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>There are several ways to consume an event. The recommended way is to use the <a href="../api/grails/events/annotation/Subscriber.html">Subscriber</a> annotation. Note that the class using this annotation needs to be a Spring bean.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="title">TotalService.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.events.annotation.*</span>
...
class TotalService {
    <span class="predefined-type">AtomicInteger</span> total = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>(<span class="integer">0</span>)
    <span class="annotation">@Subscriber</span>
    <span class="type">void</span> onSum(<span class="type">int</span> num) {
        total.addAndGet(num)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, every time a <code>sum</code> event occurs the subscriber will be invoked.</p>
</div>
<div class="paragraph">
<p>Once again the method name is used by default for the event id, although it can start with the word "on". In other words either a method name of <code>sum</code> or <code>onSum</code> would work for the above example. Or alternatively you can provide the event id to subscribe to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Subscriber</span>(<span class="string"><span class="delimiter">'</span><span class="content">myEvent</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you wish to subscribe to events dynamically or need more flexibility, then another option is to interact with the <code>EventBus</code> directly. For example:</p>
</div>
<div class="listingblock">
<div class="title">TotalService.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.events.bus.EventBusAware</span>
<span class="keyword">import</span> <span class="include">javax.annotation.PostConstruct</span>
...
class TotalService <span class="directive">implements</span> EventBusAware {
    <span class="predefined-type">AtomicInteger</span> total = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>(<span class="integer">0</span>)

    <span class="annotation">@PostConstruct</span>
    <span class="type">void</span> init() {
        eventBus.subscribe(<span class="string"><span class="delimiter">&quot;</span><span class="content">sum</span><span class="delimiter">&quot;</span></span>) { <span class="type">int</span> num -&gt;
            total.addAndGet(num)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example the <code>TotalService</code> calls <code>subscribe</code> and passes a closure within a method called <code>init</code>. The <code>init</code> method is annotated with the annotation <code>@PostConstruct</code> so that is called after the <code>EventBus</code> has been injected by Spring, ensuring it is only called once and the events are correctly subscribed to.</p>
</div>


<h2 id="annotations">3.3 Reactor Spring Annotations</h2>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/events/annotations.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>In Grails versions earlier than 3.3, Grails used Reactor 2.x which provided <code>@Consumer</code> and <code>@Selector</code> annotations to listen for events. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">reactor.spring.context.annotation.*</span>

<span class="annotation">@Consumer</span>
<span class="type">class</span> <span class="class">MyService</span> {
        <span class="annotation">@Selector</span>(<span class="string"><span class="delimiter">'</span><span class="content">myEvent</span><span class="delimiter">'</span></span>)
        <span class="type">void</span> myEventListener(<span class="predefined-type">Object</span> data) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">GOT EVENT </span><span class="inline"><span class="inline-delimiter">$</span>data</span><span class="delimiter">&quot;</span></span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Within the <code>grails-events-compat</code> dependency Grails 3.3 and above ship versions of these annotations that bridge and provide compatibility for applications upgrading to Grails 3.3, however these annotations are considered deprecated and the <a href="../api/grails/events/annotation/Subscriber.html">Subscriber</a> annotation should be used instead which provides equivalent functionality.</p>
</div>


<h2 id="gormEvents">3.4 Events from GORM</h2>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/events/gormEvents.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>GORM defines a <a href="http://gorm.grails.org/latest/api/org/grails/datastore/mapping/engine/event/package-summary.html">number of useful events</a> that you can listen for.</p>
</div>
<div class="paragraph">
<p>To subscribe for an event just define a <code>Subscriber</code> that receives the event type as an argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.events.annotation.*</span>
...
Collection&lt;PreInsertEvent&gt; insertEvents = <span class="keyword">new</span> ConcurrentLinkedDeque&lt;&gt;()

<span class="annotation">@Subscriber</span>
<span class="type">void</span> beforeInsert(PreInsertEvent event) {
    insertEvents.add(event)
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These events are triggered asynchronously, and so cannot cancel or manipulate the persistence operations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you wish to a define a synchronous listener then you should instead use the <code>Listener</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.events.annotation.gorm.*</span>
...
<span class="annotation">@Listener</span>
<span class="type">void</span> tagFunnyBooks(PreInsertEvent event) {
    <span class="predefined-type">String</span> title = event.getEntityAccess().getPropertyValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>)
    <span class="keyword">if</span>(title?.contains(<span class="string"><span class="delimiter">&quot;</span><span class="content">funny</span><span class="delimiter">&quot;</span></span>)) {
        event.getEntityAccess().setProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Humor - </span><span class="inline"><span class="inline-delimiter">${</span>title<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>.toString())
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you plan to modify properties of an entity being inserted, use the <code>EntityAccess</code> object as shown above. If you set properties directly on the the entity it will be marked as dirty which will cause another update to be issued.
</td>
</tr>
</table>
</div>


<h2 id="springEvents">3.5 Events from Spring</h2>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/events/springEvents.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>Spring also fires a number of useful events. All events in the <code>org.springframework</code> use the <code>spring</code> namespace. However, these events are disabled by default as they add a performance overhead.</p>
</div>
<div class="paragraph">
<p>To enable Spring Event translation set <code>grails.events.spring</code> to <code>true</code> in <code>application.yml</code> prior to defining subscribers.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.events.annotation.*</span>
<span class="keyword">import</span> <span class="include">org.springframework.web.context.support.*</span>
<span class="keyword">import</span> <span class="include">org.springframework.boot.context.event.*</span>
...

<span class="annotation">@Events</span>(namespace=<span class="string"><span class="delimiter">&quot;</span><span class="content">spring</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">MyService</span> {

    <span class="annotation">@Subscriber</span>
    <span class="type">void</span> applicationStarted(ApplicationStartedEvent event) {
        <span class="comment">// fired when the application starts</span>
    }

    <span class="annotation">@Subscriber</span>
    <span class="type">void</span> servletRequestHandled(RequestHandledEvent event) {
        <span class="comment">// fired each time a request is handled</span>
    }
}</code></pre>
</div>
</div>


<h2 id="configure">3.6 Configure the Default Event Bus</h2>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/events/configure.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>If you include one of the aforementioned concrete <code>EventBus</code> implementations for RxJava or GPars then it is a matter of configuring the appropriate implementation.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
With RxJava 1.x this is done with <a href="http://reactivex.io/RxJava/javadoc/rx/plugins/RxJavaHooks.html">RxJavaHooks</a>, with RxJava 2.x with <a href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/plugins/RxJavaPlugins.html">RxJavaPlugins</a> and with GPars with <a href="http://gpars.org/1.2.0/groovydoc//groovyx/gpars/GParsConfig.html">GParsConfig</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you use the default implementation then you can override the thread pool used by the <code>EventBus</code> by registering the appropriate bean in <code>grails-app/conf/spring/resources.groovy</code>:</p>
</div>
<div class="listingblock">
<div class="title">grails-app/conf/spring/resources.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.grails.events.bus.*</span>
<span class="keyword">import</span> <span class="include">java.util.concurrent.*</span>

beans = {
    eventBus(ExecutorEventBus, <span class="predefined-type">Executors</span>.newFixedThreadPool(<span class="integer">5</span>))
}</code></pre>
</div>
</div>


<h1 id="asyncGorm">4 Asynchronous GORM</h1>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/asyncGorm.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>Since Grails 2.3, GORM features an asynchronous programming model that works across all supported datastores (Hibernate, MongoDB etc.).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although GORM executes persistence operations asynchronously, these operations still block as the underlying database drivers are not asynchronous. Asynchornous GORM is designed to allow you to isolate these blocking operations onto a separate thread you can scale and control allowing your controller layer to remain non-blocking.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_the_asyncentity_trait">The AsyncEntity Trait</h3>
<div class="paragraph">
<p>Since Grails 3.3, the asynchronous part of GORM is optional. To enable it you first need to add the <code>grails-datastore-gorm-async</code> dependency to <code>build.gradle</code>:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">compile <span class="string"><span class="delimiter">&quot;</span><span class="content">org.grails:grails-datastore-gorm-async</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then in your domain classes you wish to allow asynchronous processing you should use the <code>AsyncEntity</code> trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.gorm.async.*</span>

<span class="type">class</span> <span class="class">MyEntity</span> <span class="directive">implements</span> AsyncEntity&lt;MyEntity&gt; {
   ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_async_namespace">Async Namespace</h3>
<div class="paragraph">
<p>The <code>AsyncEntity</code> entity trait provides an <code>async</code> namespace that exposes all of the GORM methods in an asynchronous manner.</p>
</div>
<div class="paragraph">
<p>For example, the following code listing reads 3 objects from the database asynchronously:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

<span class="keyword">def</span> p1 = Person.async.get(<span class="integer">1L</span>)
<span class="keyword">def</span> p2 = Person.async.get(<span class="integer">2L</span>)
<span class="keyword">def</span> p3 = Person.async.get(<span class="integer">3L</span>)
<span class="keyword">def</span> results = waitAll(p1, p2, p3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the <code>async</code> namespace, all the regular GORM methods are available (even dynamic finders), but instead of executing synchronously, the query is run in the background and a <code>Promise</code> instance is returned.</p>
</div>
<div class="paragraph">
<p>The following code listing shows a few common examples of GORM queries executed asynchronously:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

Person.async.list().onComplete { <span class="predefined-type">List</span> results -&gt;
  println <span class="string"><span class="delimiter">&quot;</span><span class="content">Got people = </span><span class="inline"><span class="inline-delimiter">${</span>results<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}
<span class="keyword">def</span> p = Person.async.getAll(<span class="integer">1L</span>, <span class="integer">2L</span>, <span class="integer">3L</span>)
<span class="predefined-type">List</span> results = p.get()

<span class="keyword">def</span> p1 = Person.async.findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Homer</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">def</span> p2 = Person.async.findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Bart</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">def</span> p3 = Person.async.findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Barney</span><span class="delimiter">&quot;</span></span>)
results = waitAll(p1, p2, p3)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_async_and_the_session">Async and the Session</h3>
<div class="paragraph">
<p>When using GORM async each promise is executed in a different thread. Since the Hibernate session is not concurrency safe, a new session is bound per thread.</p>
</div>
<div class="paragraph">
<p>This is an important consideration when using GORM async (particularly with Hibernate as the persistence engine). The objects returned from asynchronous queries will be detached entities.</p>
</div>
<div class="paragraph">
<p>This means you cannot save objects returned from asynchronous queries without first merging them back into session. For example the following will not work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> promise = Person.async.findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Homer</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">def</span> person = promise.get()
person.firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Bart</span><span class="delimiter">&quot;</span></span>
person.save()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead you need to merge the object with the session bound to the calling thread. The above code needs to be written as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> promise = Person.async.findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Homer</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">def</span> person = promise.get()
person.merge()
person.firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Bart</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>merge()</code> is called first because it may refresh the object from the cache or database, which would result in the change being lost. In general it is not recommended to read and write objects in different threads and you should avoid this technique unless absolutely necessary.</p>
</div>
<div class="paragraph">
<p>Finally, another issue with detached objects is that association lazy loading <strong>will not</strong> work and you will encounter <code>LazyInitializationException</code> errors if you do so. If you plan to access the associated objects of those returned from asynchronous queries you should use eager queries (which is recommended anyway to avoid N+1 problems).</p>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_asynchronous_gorm_calls">Multiple Asynchronous GORM calls</h3>
<div class="paragraph">
<p>As discussed in the previous section you should avoid reading and writing objects in different threads as merging tends to be inefficient.</p>
</div>
<div class="paragraph">
<p>However, if you wish to do more complex GORM work asynchronously then the GORM async namespace provides a <code>task</code> method that makes this possible. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> promise = Person.async.task {
    withTransaction {
       <span class="keyword">def</span> person = findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Homer</span><span class="delimiter">&quot;</span></span>)
       person.firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Bart</span><span class="delimiter">&quot;</span></span>
       person.save(<span class="key">flush</span>:<span class="predefined-constant">true</span>)
    }
}

Person updatedPerson = promise.get()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the GORM <code>task</code> method differs from the static <code>Promises.task</code> method in that it deals with binding a new session to the asynchronous thread for you. If you do not use the GORM version and do asynchronous work with GORM then you need to do this manually. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

<span class="keyword">def</span> promise = task {
    Person.withNewSession {
            <span class="comment">// your logic here</span>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_async_detachedcriteria">Async DetachedCriteria</h3>
<div class="paragraph">
<p>The <code>DetachedCriteria</code> class also supports the <code>async</code> namespace. For example you can do the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">DetachedCriteria query = Person.where {
    lastName == <span class="string"><span class="delimiter">&quot;</span><span class="content">Simpson</span><span class="delimiter">&quot;</span></span>
}

<span class="keyword">def</span> promise = query.async.list()</code></pre>
</div>
</div>
</div>


<h1 id="rxjava">5 RxJava Support</h1>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/rxjava.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>Since Grails 3.2, you can use <a href="https://github.com/ReactiveX/RxJava">RxJava</a> to write reactive logic in your Grails controllers that leverages the underlying containers asynchronous processing capabilities.</p>
</div>
<div class="paragraph">
<p>To get started simply declare a dependency on the plugin in <code>build.gradle</code>:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    ...
    compile <span class="string"><span class="delimiter">'</span><span class="content">org.grails.plugins:rxjava</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then return <code>rx.Observable</code> as a return value from any controller and Grails will automatically apply the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a new asynchronous request</p>
</li>
<li>
<p>Spawn a new thread that subscribes to the observable</p>
</li>
<li>
<p>When the observable emits a result, process the result using the <a href="../ref/Controllers/respond.html">respond</a> method.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For more detailed instructions on how to use the RxJava plugin see the <a href="https://grails-plugins.github.io/grails-rxjava/latest/">user guide documentation</a> for the plugin.</p>
</div>


<h2 id="serverSentEvents">5.1 Server Sent Events</h2>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/rxjava/serverSentEvents.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>Server-sent events (SSE) is a technology where a browser receives automatic updates from a server via HTTP connection. The Server-Sent Events EventSource API is standardized as part of HTML5 by the W3C.</p>
</div>
<div class="paragraph">
<p>The <a href="https://grails-plugins.github.io/grails-rxjava/latest/">RxJava plugin</a> adds support for SSE to Grails making it simple to write controllers that maintain continuous non-blocking communication with a JavaScript client.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> <span class="function">index</span>() {

    rx.stream { <span class="predefined-type">Observer</span> observer -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
       <span class="keyword">for</span>(i <span class="keyword">in</span> (<span class="integer">0</span>..<span class="integer">5</span>)) {
           <span class="keyword">if</span>(i % <span class="integer">2</span> == <span class="integer">0</span>) {
               observer.onNext(
                   rx.render(<span class="string"><span class="delimiter">&quot;</span><span class="content">Tick</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
               )
           }
           <span class="keyword">else</span> {
               observer.onNext(
                   rx.render(<span class="string"><span class="delimiter">&quot;</span><span class="content">Tock</span><span class="delimiter">&quot;</span></span>)
               )

           }
           sleep <span class="integer">1000</span> <i class="conum" data-value="3"></i><b>(3)</b>
       }
       observer.onCompleted() <i class="conum" data-value="4"></i><b>(4)</b>
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Call the <code>stream</code> method passing a closure that accepts an <code>rx.Subscriber</code> to start sending events</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Emit a one or many items using <code>onNext</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Call <code>sleep</code> to simulate a slow request</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Call <code>onCompleted</code> to complete the request</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more detailed instructions on how to use SSE and the RxJava plugin see the <a href="https://grails-plugins.github.io/grails-rxjava/latest/">user guide documentation</a> for the plugin.</p>
</div>


<h2 id="rxGorm">5.2 RxGORM</h2>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/rxjava/rxGorm.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p><a href="http://gorm.grails.org/6.0.x/rx/manual/">RxGORM</a> is new implementation of GORM that has the following goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reactive</p>
</li>
<li>
<p>Non-blocking</p>
</li>
<li>
<p>Stateless</p>
</li>
<li>
<p>Simple</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>RxGORM, unlike the <a href="async.html#asyncGorm">Asynchronous GORM</a> implementation, aims to be truly non-blocking, down to the driver level.</p>
</div>
<div class="paragraph">
<p>The following in an example of RxGORM in action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="predefined-type">Book</span>.get(id)
    .subscribe { <span class="predefined-type">Book</span> <span class="local-variable">it</span> -&gt;
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Title = </span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span>.title<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can combine RxGORM with the <a href="https://grails-plugins.github.io/grails-rxjava/latest">RxJava</a> plugin to implement reactive responses from Grails controllers. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> <span class="function">show</span>() {
        <span class="comment">// returns an rx.Observable</span>
    <span class="predefined-type">Book</span>.get(params.id?.toString())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information on how to use RxGORM, see the <a href="http://gorm.grails.org/latest/rx/manual/">RxGORM user guide</a>.</p>
</div>


<h1 id="asyncRequests">6 Asynchronous Request Handling</h1>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/asyncRequests.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>If you are deploying to a Servlet 3.0 container such as Tomcat 7 and above then it is possible to deal with responses asynchronously.</p>
</div>
<div class="paragraph">
<p>In general for controller actions that execute quickly there is little benefit in handling requests asynchronously. However, for long running controller actions it is extremely beneficial.</p>
</div>
<div class="paragraph">
<p>The reason being that with an asynchronous / non-blocking response, the one thread == one request == one response relationship is broken. The container can keep a client response open and active, and at the same time return the thread back to the container to deal with another request, improving scalability.</p>
</div>
<div class="paragraph">
<p>For example, if you have 70 available container threads and an action takes a minute to complete, if the actions are not executed in a non-blocking fashion the likelihood of all 70 threads being occupied and the container not being able to respond is quite high and you should consider asynchronous request processing.</p>
</div>
<div class="paragraph">
<p>Since Grails 2.3, Grails features a simplified API for creating asynchronous responses built on the <code>Promise</code> mechanism discussed previously.</p>
</div>
<div class="paragraph">
<p>The implementation is based on Servlet 3.0 async. So, to enable the async features you need to set your servlet target version to 3.0 in application.yml:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="key">grails</span>:
    <span class="key">servlet</span>:
        <span class="key">version</span>: <span class="float">3.0</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_async_models">Async Models</h4>
<div class="paragraph">
<p>A typical activity in a Grails controller is to produce a model (a map of key/value pairs) that can be rendered by a view.</p>
</div>
<div class="paragraph">
<p>If the model takes a while to produce then the server could arrive at a blocking state, impacting scalability. You tell Grails to build the model asynchronously by returning a <code>grails.async.PromiseMap</code> via the <code>Promises.tasks</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.web.WebPromises.*</span>
...
def index() {
   tasks <span class="key">books</span>: <span class="predefined-type">Book</span>.async.list(),
         <span class="key">totalBooks</span>: <span class="predefined-type">Book</span>.async.count(),
         <span class="key">otherValue</span>: {
           <span class="comment">// do hard work</span>
         }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Grails will handle the response asynchronously, waiting for the promises to complete before rendering the view. The equivalent synchronous action of the above is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> <span class="function">index</span>() {
    <span class="keyword">def</span> otherValue = ...
        [ <span class="key">books</span>: <span class="predefined-type">Book</span>.list() ,
          <span class="key">totalBooks</span>: <span class="predefined-type">Book</span>.count(),
          <span class="key">otherValue</span>: otherValue  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can even render different view by passing the <code>PromiseMap</code> to the <code>model</code> attribute of the <code>render</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.WebPromises.*</span>
...
def index() {
   render <span class="key">view</span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">myView</span><span class="delimiter">&quot;</span></span>, <span class="key">model</span>: tasks( <span class="key">one</span>:{ <span class="integer">2</span> * <span class="integer">2</span> },
                                       <span class="key">two</span>:{ <span class="integer">3</span> * <span class="integer">3</span> } )
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_async_response_rendering">Async Response Rendering</h4>
<div class="paragraph">
<p>You can also write to the response asynchronously using promises in Grails 2.3 and above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.WebPromises.*</span>
<span class="type">class</span> <span class="class">StockController</span> {

    <span class="keyword">def</span> <span class="function">stock</span>(<span class="predefined-type">String</span> ticker) {
       task {
           ticker = ticker ?: <span class="string"><span class="delimiter">'</span><span class="content">GOOG</span><span class="delimiter">'</span></span>
           <span class="keyword">def</span> url = <span class="keyword">new</span> <span class="predefined-type">URL</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://download.finance.yahoo.com/d/quotes.csv?s=</span><span class="inline"><span class="inline-delimiter">${</span>ticker<span class="inline-delimiter">}</span></span><span class="content">&amp;f=nsl1op&amp;e=.csv</span><span class="delimiter">&quot;</span></span>)
           <span class="predefined-type">Double</span> price = url.text.split(<span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span>)[-<span class="integer">1</span>] <span class="keyword">as</span> <span class="predefined-type">Double</span>
           render <span class="string"><span class="delimiter">&quot;</span><span class="content">ticker: </span><span class="inline"><span class="inline-delimiter">$</span>ticker</span><span class="content">, price: </span><span class="char">\$</span><span class="content">price</span><span class="delimiter">&quot;</span></span>
       }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above example using Yahoo Finance to query stock prices, executing asynchronously and only rendering the response once the result has been obtained. This is done by returning a <code>Promise</code> instance from the controller action.</p>
</div>
<div class="paragraph">
<p>If the Yahoo URL is unresponsive the original request thread will not be blocked and the container will not become unresponsive.</p>
</div>
</div>


<h1 id="asyncServletApi">7 Servlet 3.0 Async</h1>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/master/src/main/docs/guide/asyncServletApi.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>In addition to the higher level async features discussed earlier in the section, you can access the raw Servlet 3.0 asynchronous API from a Grails application.</p>
</div>
<div class="sect3">
<h4 id="_servlet_3_0_asynchronous_rendering">Servlet 3.0 Asynchronous Rendering</h4>
<div class="paragraph">
<p>To do so your should first implement the <code>grails.async.web.AsyncController</code> trait in your controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.async.web.*</span>

...
class BookController <span class="directive">implements</span> AsyncController {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can render content (templates, binary data etc.) in an asynchronous manner by calling the <code>startAsync</code> method which returns an instance of the Servlet 3.0 <code>AsyncContext</code>. Once you have a reference to the <code>AsyncContext</code> you can use Grails' regular render method to render content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> <span class="function">index</span>() {
    <span class="keyword">def</span> ctx = startAsync()
    ctx.start {
        <span class="keyword">new</span> <span class="predefined-type">Book</span>(<span class="key">title</span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">The Stand</span><span class="delimiter">&quot;</span></span>).save()
        render <span class="key">template</span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">books</span><span class="delimiter">&quot;</span></span>, <span class="key">model</span>:[<span class="key">books</span>:<span class="predefined-type">Book</span>.list()]
        ctx.complete()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you must call the <code>complete()</code> method to terminate the connection.</p>
</div>
</div>
<div class="sect3">
<h4 id="_resuming_an_async_request">Resuming an Async Request</h4>
<div class="paragraph">
<p>You resume processing of an async request (for example to delegate to view rendering) by using the <code>dispatch</code> method of the <code>AsyncContext</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> <span class="function">index</span>() {
    <span class="keyword">def</span> ctx = startAsync()
    ctx.start {
        <span class="comment">// do working</span>
        ...
        <span class="comment">// render view</span>
        ctx.dispatch()
    }
}</code></pre>
</div>
</div>
</div>

            </div>
        </td>
        <td id="col2">
            <div class="local clearfix">
                
                <div id="table-of-content">
                    <h2>Table of Contents</h2>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#introduction"><strong>1</strong><span>Introduction</span></a></div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#promises"><strong>2</strong><span>Promises</span></a></div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#events"><strong>3</strong><span>Events</span></a></div>
                    
                    <div class="toc-item" style="margin-left:10px"><a href="#notifying"><strong>3.1</strong><span>Event Publishing</span></a></div>
                    
                    <div class="toc-item" style="margin-left:10px"><a href="#consuming"><strong>3.2</strong><span>Subscribing to Events</span></a></div>
                    
                    <div class="toc-item" style="margin-left:10px"><a href="#annotations"><strong>3.3</strong><span>Reactor Spring Annotations</span></a></div>
                    
                    <div class="toc-item" style="margin-left:10px"><a href="#gormEvents"><strong>3.4</strong><span>Events from GORM</span></a></div>
                    
                    <div class="toc-item" style="margin-left:10px"><a href="#springEvents"><strong>3.5</strong><span>Events from Spring</span></a></div>
                    
                    <div class="toc-item" style="margin-left:10px"><a href="#configure"><strong>3.6</strong><span>Configure the Default Event Bus</span></a></div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#asyncGorm"><strong>4</strong><span>Asynchronous GORM</span></a></div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#rxjava"><strong>5</strong><span>RxJava Support</span></a></div>
                    
                    <div class="toc-item" style="margin-left:10px"><a href="#serverSentEvents"><strong>5.1</strong><span>Server Sent Events</span></a></div>
                    
                    <div class="toc-item" style="margin-left:10px"><a href="#rxGorm"><strong>5.2</strong><span>RxGORM</span></a></div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#asyncRequests"><strong>6</strong><span>Asynchronous Request Handling</span></a></div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#asyncServletApi"><strong>7</strong><span>Servlet 3.0 Async</span></a></div>
                    
                    <div style="clear:both" ></div>
                </div>
                
            </div>
        </td>
    </tr>
</table>

<div id="footer">
    
    
</div>


</body>
</html>
