<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script src="/cdn-cgi/apps/head/3cOPSgo5Omz84ycX7CvigfX4cpw.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-82213539-2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-82213539-2');
    </script>
    <title>4 Asynchronous GORM 5.0.0-SNAPSHOT</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8"/>
    <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8"/>
    <script type="text/javascript">
function addJsClass() {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
</head>

<body class="body" onload="addJsClass();">
<div id="navigation">
    <div class="navTitle">
        
        Grails Async Framework
    </div>
    <div class="navLinks">
        <ul>
            <li>
                <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                    <a href="../guide/index.html" class="button">Table of contents</a>

                    <div id="nav-summary-childs" style="display:none;">
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/introduction.html"><strong>1</strong><span>Introduction</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/promises.html"><strong>2</strong><span>Promises</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/events.html"><strong>3</strong><span>Events</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/asyncGorm.html"><strong>4</strong><span>Asynchronous GORM</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/rxjava.html"><strong>5</strong><span>RxJava Support</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/asyncRequests.html"><strong>6</strong><span>Asynchronous Request Handling</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/asyncServletApi.html"><strong>7</strong><span>Servlet 3.0 Async</span></a>
                        </div>
                        
                    </div>
                </div>
            </li>
            <li class="separator selected">
                <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
            </li>
        </ul>
    </div>


</div>

<table id="colset" border="0" cellpadding="0" cellspacing="0">
    <tr>
        <td id="col1">
            <div id="main" class="corner-all">

                
                    <div class="toc-item prev-left"><a href="../guide/events.html">&lt;&lt; <strong>3</strong><span>Events</span></a></div>
                

                <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                
                    <div class="toc-item next-right"><a href="../guide/rxjava.html"><strong>5</strong><span>RxJava Support</span> >></a></div>
                


                <div class="project">
                    <h1>4 Asynchronous GORM</h1>

                    <p><strong>Version:</strong> 5.0.0-SNAPSHOT</p>
                </div>

                

                

<h1 id="asyncGorm">4 Asynchronous GORM</h1>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/5.0.x/src/main/docs/guide/asyncGorm.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>Since Grails 2.3, GORM features an asynchronous programming model that works across all supported datastores (Hibernate, MongoDB etc.).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although GORM executes persistence operations asynchronously, these operations still block as the underlying database drivers are not asynchronous. Asynchornous GORM is designed to allow you to isolate these blocking operations onto a separate thread you can scale and control allowing your controller layer to remain non-blocking.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_the_asyncentity_trait">The AsyncEntity Trait</h3>
<div class="paragraph">
<p>Since Grails 3.3, the asynchronous part of GORM is optional. To enable it you first need to add the <code>grails-datastore-gorm-async</code> dependency to <code>build.gradle</code>:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">compile <span class="string"><span class="delimiter">&quot;</span><span class="content">org.grails:grails-datastore-gorm-async</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then in your domain classes you wish to allow asynchronous processing you should use the <code>AsyncEntity</code> trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.gorm.async.*</span>

<span class="type">class</span> <span class="class">MyEntity</span> <span class="directive">implements</span> AsyncEntity&lt;MyEntity&gt; {
   ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_async_namespace">Async Namespace</h3>
<div class="paragraph">
<p>The <code>AsyncEntity</code> entity trait provides an <code>async</code> namespace that exposes all of the GORM methods in an asynchronous manner.</p>
</div>
<div class="paragraph">
<p>For example, the following code listing reads 3 objects from the database asynchronously:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

<span class="keyword">def</span> p1 = Person.async.get(<span class="integer">1L</span>)
<span class="keyword">def</span> p2 = Person.async.get(<span class="integer">2L</span>)
<span class="keyword">def</span> p3 = Person.async.get(<span class="integer">3L</span>)
<span class="keyword">def</span> results = waitAll(p1, p2, p3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the <code>async</code> namespace, all the regular GORM methods are available (even dynamic finders), but instead of executing synchronously, the query is run in the background and a <code>Promise</code> instance is returned.</p>
</div>
<div class="paragraph">
<p>The following code listing shows a few common examples of GORM queries executed asynchronously:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

Person.async.list().onComplete { <span class="predefined-type">List</span> results -&gt;
  println <span class="string"><span class="delimiter">&quot;</span><span class="content">Got people = </span><span class="inline"><span class="inline-delimiter">${</span>results<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}
<span class="keyword">def</span> p = Person.async.getAll(<span class="integer">1L</span>, <span class="integer">2L</span>, <span class="integer">3L</span>)
<span class="predefined-type">List</span> results = p.get()

<span class="keyword">def</span> p1 = Person.async.findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Homer</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">def</span> p2 = Person.async.findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Bart</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">def</span> p3 = Person.async.findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Barney</span><span class="delimiter">&quot;</span></span>)
results = waitAll(p1, p2, p3)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_async_and_the_session">Async and the Session</h3>
<div class="paragraph">
<p>When using GORM async each promise is executed in a different thread. Since the Hibernate session is not concurrency safe, a new session is bound per thread.</p>
</div>
<div class="paragraph">
<p>This is an important consideration when using GORM async (particularly with Hibernate as the persistence engine). The objects returned from asynchronous queries will be detached entities.</p>
</div>
<div class="paragraph">
<p>This means you cannot save objects returned from asynchronous queries without first merging them back into session. For example the following will not work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> promise = Person.async.findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Homer</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">def</span> person = promise.get()
person.firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Bart</span><span class="delimiter">&quot;</span></span>
person.save()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead you need to merge the object with the session bound to the calling thread. The above code needs to be written as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> promise = Person.async.findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Homer</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">def</span> person = promise.get()
person.merge()
person.firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Bart</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>merge()</code> is called first because it may refresh the object from the cache or database, which would result in the change being lost. In general it is not recommended to read and write objects in different threads and you should avoid this technique unless absolutely necessary.</p>
</div>
<div class="paragraph">
<p>Finally, another issue with detached objects is that association lazy loading <strong>will not</strong> work and you will encounter <code>LazyInitializationException</code> errors if you do so. If you plan to access the associated objects of those returned from asynchronous queries you should use eager queries (which is recommended anyway to avoid N+1 problems).</p>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_asynchronous_gorm_calls">Multiple Asynchronous GORM calls</h3>
<div class="paragraph">
<p>As discussed in the previous section you should avoid reading and writing objects in different threads as merging tends to be inefficient.</p>
</div>
<div class="paragraph">
<p>However, if you wish to do more complex GORM work asynchronously then the GORM async namespace provides a <code>task</code> method that makes this possible. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> promise = Person.async.task {
    withTransaction {
       <span class="keyword">def</span> person = findByFirstName(<span class="string"><span class="delimiter">&quot;</span><span class="content">Homer</span><span class="delimiter">&quot;</span></span>)
       person.firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Bart</span><span class="delimiter">&quot;</span></span>
       person.save(<span class="key">flush</span>:<span class="predefined-constant">true</span>)
    }
}

Person updatedPerson = promise.get()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the GORM <code>task</code> method differs from the static <code>Promises.task</code> method in that it deals with binding a new session to the asynchronous thread for you. If you do not use the GORM version and do asynchronous work with GORM then you need to do this manually. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

<span class="keyword">def</span> promise = task {
    Person.withNewSession {
            <span class="comment">// your logic here</span>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_async_detachedcriteria">Async DetachedCriteria</h3>
<div class="paragraph">
<p>The <code>DetachedCriteria</code> class also supports the <code>async</code> namespace. For example you can do the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">DetachedCriteria query = Person.where {
    lastName == <span class="string"><span class="delimiter">&quot;</span><span class="content">Simpson</span><span class="delimiter">&quot;</span></span>
}

<span class="keyword">def</span> promise = query.async.list()</code></pre>
</div>
</div>
</div>


                <div style="clear:both;margin-top:15px;"></div>
                
                    <div class="toc-item prev-left"><a href="../guide/events.html">&lt;&lt; <strong>3</strong><span>Events</span></a></div>
                
                    <div class="toc-item next-right"><a href="../guide/rxjava.html"><strong>5</strong><span>RxJava Support</span> >></a></div>
                
                <div style="clear:both"></div>
            </div>
        </td>
        <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                </div>
            </div>
        </td>
    </tr>
</table>

<div id="footer">
    
    
</div>

<script type="text/javascript" src="../js/docs.js"></script>

</body>
</html>
