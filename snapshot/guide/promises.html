<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script src="/cdn-cgi/apps/head/3cOPSgo5Omz84ycX7CvigfX4cpw.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-82213539-2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-82213539-2');
    </script>
    <title>2 Promises 5.0.0</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8"/>
    <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8"/>
    <script type="text/javascript">
function addJsClass() {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
</head>

<body class="body" onload="addJsClass();">
<div id="navigation">
    <div class="navTitle">
        
        Grails Async Framework
    </div>
    <div class="navLinks">
        <ul>
            <li>
                <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                    <a href="../guide/index.html" class="button">Table of contents</a>

                    <div id="nav-summary-childs" style="display:none;">
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/introduction.html"><strong>1</strong><span>Introduction</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/promises.html"><strong>2</strong><span>Promises</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/events.html"><strong>3</strong><span>Events</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/asyncGorm.html"><strong>4</strong><span>Asynchronous GORM</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/rxjava.html"><strong>5</strong><span>RxJava Support</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/asyncRequests.html"><strong>6</strong><span>Asynchronous Request Handling</span></a>
                        </div>
                        
                        <div class="toc-item" style="margin-left:0"><a href="../guide/asyncServletApi.html"><strong>7</strong><span>Servlet 3.0 Async</span></a>
                        </div>
                        
                    </div>
                </div>
            </li>
            <li class="separator selected">
                <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
            </li>
        </ul>
    </div>


</div>

<table id="colset" border="0" cellpadding="0" cellspacing="0">
    <tr>
        <td id="col1">
            <div id="main" class="corner-all">

                
                    <div class="toc-item prev-left"><a href="../guide/introduction.html">&lt;&lt; <strong>1</strong><span>Introduction</span></a></div>
                

                <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                
                    <div class="toc-item next-right"><a href="../guide/events.html"><strong>3</strong><span>Events</span> >></a></div>
                


                <div class="project">
                    <h1>2 Promises</h1>

                    <p><strong>Version:</strong> 5.0.0</p>
                </div>

                

                

<h1 id="promises">2 Promises</h1>

<div class='contribute-btn'>
    <button type='button' class='btn btn-default' onclick='window.location.href="https://github.com/grails/grails-async/edit/5.0.x/src/main/docs/guide/promises.adoc"'>
        <i class='fa fa-pencil-square-o'></i> Improve this doc
    </button>
</div>


<div class="paragraph">
<p>A Promise is a concept being embraced by many concurrency frameworks. They are similar to <code>java.util.concurrent.Future</code> instances, but include a more user friendly exception handling model, useful features like chaining and the ability to attach listeners.</p>
</div>
<div class="paragraph">
<p>To use the Grails Promise abstraction you should add a dependency on the <code>async</code> plugin to your <code>build.gradle</code> file:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">runtime "org.grails.plugins:async:5.0.0"</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_promise_basics">Promise Basics</h3>
<div class="paragraph">
<p>In Grails the <code>grails.async.Promises</code> class provides the entry point to the Promise API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To create promises you can use the <code>task</code> method, which returns an instance of the <code>grails.async.Promise</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> p1 = task { <span class="integer">2</span> * <span class="integer">2</span> }
<span class="keyword">def</span> p2 = task { <span class="integer">4</span> * <span class="integer">4</span> }
<span class="keyword">def</span> p3 = task { <span class="integer">8</span> * <span class="integer">8</span> }
<span class="keyword">assert</span> [<span class="integer">4</span>,<span class="integer">16</span>,<span class="integer">64</span>] == waitAll(p1, p2, p3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>waitAll</code> method waits synchronously, blocking the current thread, for all of the concurrent tasks to complete and returns the results.</p>
</div>
<div class="paragraph">
<p>If you prefer not to block the current thread you can use the <code>onComplete</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">onComplete([p1,p2,p3]) { <span class="predefined-type">List</span> results -&gt;
   <span class="keyword">assert</span> [<span class="integer">4</span>,<span class="integer">16</span>,<span class="integer">64</span>] == results
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>waitAll</code> method will throw an exception if an error occurs executing one of the promises. The originating exception will be thrown. The <code>onComplete</code> method, however, will simply not execute the passed closure if an exception occurs. You can register an <code>onError</code> listener if you wish to handle exceptions without blocking:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">onError([p1,p2,p3]) { <span class="predefined-type">Throwable</span> t -&gt;
   println <span class="string"><span class="delimiter">&quot;</span><span class="content">An error occured </span><span class="inline"><span class="inline-delimiter">${</span>t.message<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have just a single long running promise then the <code>grails.async.Promise</code> interface provides a similar API on the promise itself. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">java.util.concurrent.TimeUnit.*</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

Promise p = task {
        <span class="comment">// Long running task</span>
}
p.onError { <span class="predefined-type">Throwable</span> err -&gt;
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">An error occured </span><span class="inline"><span class="inline-delimiter">${</span>err.message<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}
p.onComplete { result -&gt;
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Promise returned </span><span class="inline"><span class="inline-delimiter">$</span>result</span><span class="delimiter">&quot;</span></span>
}
<span class="comment">// block until result is called</span>
<span class="keyword">def</span> result = p.get()
<span class="comment">// block for the specified time</span>
<span class="keyword">def</span> result = p.get(<span class="integer">1</span>,MINUTES)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_promisefactory_interface">The PromiseFactory Interface</h3>
<div class="paragraph">
<p>By default the <code>Promises</code> static methods use an instance of <code>PromiseFactory</code>. This <code>PromiseFactory</code> interface has various implementations. The default implementation is <a href="../api/org/grails/async/factory/future/CachedThreadPoolPromiseFactory.html">CachedThreadPoolPromiseFactory</a> which uses a thread pool that will create threads as needed (the same as <code>java.util.concurrent.Executors.newCachedThreadPool()</code>)</p>
</div>
<div class="paragraph">
<p>However, the design of the Grails promises framework is such that you can swap out the underlying implementation for your own or one of the pre-supported implementations. For example to use RxJava 1.x simply add the RxJava dependency to <code>build.gradle</code>:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">runtime "org.grails:grails-async-rxjava:5.0.0"</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the above in place RxJava 1.x will be used to create <code>Promise</code> instances.</p>
</div>
<div class="paragraph">
<p>The following table summarizes the available implementation and the dependency that should be added to activate them:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Promise Factory Implementations</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Framework</th>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Implementation Class</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPars 1.2.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>grails-async-gpars</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.grails.async.factory.gpars.GparsPromiseFactory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RxJava 1.2.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>grails-async-rxjava</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.grails.async.factory.rxjava.RxPromiseFactory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RxJava 2.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>grails-async-rxjava2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.grails.async.factory.rxjava2.RxPromiseFactory</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can also override the <code>grails.async.PromiseFactory</code> class used by <code>Promises</code> by setting the <code>promiseFactory</code> static field.</p>
</div>
<div class="paragraph">
<p>One common use case for this is unit testing, typically you do not want promises to execute asynchronously during unit tests, as this makes tests harder to write. For this purpose Grails ships with a <code>org.grails.async.factory.SynchronousPromiseFactory</code> instance that makes it easier to test promises:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.grails.async.factory.*</span>
<span class="keyword">import</span> <span class="include">grails.async.*</span>

Promises.promiseFactory = <span class="keyword">new</span> SynchronousPromiseFactory()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the <code>PromiseFactory</code> mechanism it is theoretically possible to plug in other concurrency libraries into the Grails framework. For this you need to override the two interfaces <code>grails.async.Promise</code> and <code>grails.async.PromiseFactory</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_promise_chaining">Promise Chaining</h3>
<div class="paragraph">
<p>It is possible to chain several promises and wait for the chain to complete using the <code>then</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="directive">final</span> polish = { ... }
<span class="directive">final</span> transform = { ... }
<span class="directive">final</span> save = { ... }
<span class="directive">final</span> notify = { ... }

Promise promise = task {
    <span class="comment">// long running task</span>
}
promise.then polish then transform then save then {
        <span class="comment">// notify end result</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an exception occurs at any point in the chain it will be propagated back to the caller and the next step in the chain will not be called.</p>
</div>
</div>
<div class="sect2">
<h3 id="_promise_lists_and_maps">Promise Lists and Maps</h3>
<div class="paragraph">
<p>Grails' async API also features the concept of a promise lists and maps. These are represented by the <code>grails.async.PromiseList</code> and <code>grails.async.PromiseMap</code> classes respectively.</p>
</div>
<div class="paragraph">
<p>The easiest way to create a promise list or map is via the <code>tasks</code> method of the <code>Promises</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

<span class="keyword">def</span> promiseList = tasks([{ <span class="integer">2</span> * <span class="integer">2</span> }, { <span class="integer">4</span> * <span class="integer">4</span>}, { <span class="integer">8</span> * <span class="integer">8</span> }])

<span class="keyword">assert</span> [<span class="integer">4</span>,<span class="integer">16</span>,<span class="integer">64</span>] == promiseList.get()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>tasks</code> method, when passed a list of closures, returns a <code>PromiseList</code>. You can also construct a <code>PromiseList</code> manually:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.async.*</span>

<span class="keyword">def</span> list = <span class="keyword">new</span> PromiseList()
list &lt;&lt; { <span class="integer">2</span> * <span class="integer">2</span> }
list &lt;&lt; { <span class="integer">4</span> * <span class="integer">4</span> }
list &lt;&lt; { <span class="integer">8</span> * <span class="integer">8</span> }
list.onComplete { <span class="predefined-type">List</span> results -&gt;
  <span class="keyword">assert</span> [<span class="integer">4</span>,<span class="integer">16</span>,<span class="integer">64</span>] == results
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>PromiseList</code> class does not implement the java.util.List interface, but instead returns a java.util.List from the get() method
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Working with <code>PromiseMap</code> instances is largely similar. Again you can either use the <code>tasks</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">static</span> <span class="include">grails.async.Promises.*</span>

<span class="keyword">def</span> promiseMap = tasks <span class="key">one</span>:{ <span class="integer">2</span> * <span class="integer">2</span> },
                       <span class="key">two</span>:{ <span class="integer">4</span> * <span class="integer">4</span>},
                       <span class="key">three</span>:{ <span class="integer">8</span> * <span class="integer">8</span> }

<span class="keyword">assert</span> [<span class="key">one</span>:<span class="integer">4</span>,<span class="key">two</span>:<span class="integer">16</span>,<span class="key">three</span>:<span class="integer">64</span>] == promiseMap.get()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or construct a <code>PromiseMap</code> manually:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.async.*</span>

<span class="keyword">def</span> map = <span class="keyword">new</span> PromiseMap()
map[<span class="string"><span class="delimiter">'</span><span class="content">one</span><span class="delimiter">'</span></span>] = { <span class="integer">2</span> * <span class="integer">2</span> }
map[<span class="string"><span class="delimiter">'</span><span class="content">two</span><span class="delimiter">'</span></span>] = { <span class="integer">4</span> * <span class="integer">4</span> }
map[<span class="string"><span class="delimiter">'</span><span class="content">three</span><span class="delimiter">'</span></span>] = { <span class="integer">8</span> * <span class="integer">8</span> }
map.onComplete { <span class="predefined-type">Map</span> results -&gt;
  <span class="keyword">assert</span> [<span class="key">one</span>:<span class="integer">4</span>,<span class="key">two</span>:<span class="integer">16</span>,<span class="key">three</span>:<span class="integer">64</span>] == results
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_delegateasync_transformation">DelegateAsync Transformation</h3>
<div class="paragraph">
<p>It is quite common to require both synchronous and asynchronous versions of the same API. Developing both can result in a maintenance problem as typically the asynchronous API would simply delegate to the synchronous version.</p>
</div>
<div class="paragraph">
<p>The <code>DelegateAsync</code> transformation is designed to mitigate this problem by transforming any synchronous API into an asynchronous one.</p>
</div>
<div class="paragraph">
<p>For example, consider the following service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">BookService</span> {
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Book</span>&gt; findBooks(<span class="predefined-type">String</span> title) {
      <span class="comment">// implementation</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>findBooks</code> method executes synchronously in the same thread as the caller. To make an asynchronous version of this API you can define another class as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">grails.async.*</span>

<span class="type">class</span> <span class="class">AsyncBookService</span> {
   <span class="annotation">@DelegateAsync</span> BookService bookService
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DelegateAsync</code> transformation will automatically add a new method that looks like the following to the <code>AsyncBookService</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Promise&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">Book</span>&gt;&gt; findBooks(<span class="predefined-type">String</span> title) {
    Promises.task {
       bookService.findBooks(title)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you see the transform adds equivalent methods that return a Promise and execute asynchronously.</p>
</div>
<div class="paragraph">
<p>The <code>AsyncBookService</code> can then be injected into other controllers and services and used as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">AsyncBookService asyncBookService
<span class="keyword">def</span> <span class="function">findBooks</span>(<span class="predefined-type">String</span> title) {
    asyncBookService.findBooks(title)
       .onComplete { <span class="predefined-type">List</span> results -&gt;
          println <span class="string"><span class="delimiter">&quot;</span><span class="content">Books = </span><span class="inline"><span class="inline-delimiter">${</span>results<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
       }
}</code></pre>
</div>
</div>
</div>


                <div style="clear:both;margin-top:15px;"></div>
                
                    <div class="toc-item prev-left"><a href="../guide/introduction.html">&lt;&lt; <strong>1</strong><span>Introduction</span></a></div>
                
                    <div class="toc-item next-right"><a href="../guide/events.html"><strong>3</strong><span>Events</span> >></a></div>
                
                <div style="clear:both"></div>
            </div>
        </td>
        <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                </div>
            </div>
        </td>
    </tr>
</table>

<div id="footer">
    
    
</div>

<script type="text/javascript" src="../js/docs.js"></script>

</body>
</html>
